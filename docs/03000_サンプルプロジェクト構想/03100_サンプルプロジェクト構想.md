# サンプルプロジェクト構想

<br>

# 文書情報
---
* **文書名**: サンプルプロジェクト構想
* **作成日**: 2025年9月6日
* **更新日**: 2025年9月6日
* **バージョン**: 1.0
* **作成者**: システム開発チーム

<br>

# 1. 目的
DatabricksとVS Codeを連携し活用するサンプルプロジェクトを通じて必要な機能を検証し、実務への適用可能性を評価する。

# 2. VS Code
## 2.1 強み
- IDE文脈との深い統合: エディタ/ワークスペース/SCM/デバッグ/タスクが拡張APIで一体化。
- 拡張の柔軟性: Webview/TreeView/Comments/Diagnostics/Code Actions でUXを構築可能。
- AI連携: GitHub Copilot Agentモードと LM Tools により会話から拡張ツールを自動起動。
- ノートブック/言語機能: Notebook API と言語拡張でセル/シンタックス/ホバー等を制御。
- セキュアな実行: Authentication/SecretStorage、Workspace Trust 等のセキュリティ機構。

## 2.2 VS Code API（ローカル参照 1.51.0 ベース）

### 2.2.0 全体像（まずここ）
- ゴール: IDE内でドキュメント/コードを“引用付き”でレビューし、根拠を提示しながら改善提案や修正適用まで完結する。
- VS Code が担うこと（要約）
  - 対象取得と文脈把握: アクティブエディタ/選択範囲/差分/言語・設定の収集
  - 起動と制御: コマンド/イベント/Activation Events（Agent モード/LM ツール含む）
  - 提示と対話: 通知/診断/Quick Fix/コメント/サイドバー/リッチUI（Webview）
  - 修正適用と連携: ファイル編集/タスク・ターミナル/外部URL/認証
  - 運用: テスト/バンドル/配布/CI、ワークスペース信頼とポリシー
- 最小コアAPI: `window`, `workspace`, `commands`, `languages`, `comments`, `scm`, `tasks`, `env`, `authentication`
- この後の構成: 2.2.1 目的別マップ → 2.2.2 6ステップの流れ → 2.2.3 設計〜運用ガイド → 2.2.4 以降が詳細（辞書）

### 2.2.1 目的別APIマップ（レビューエージェント向け）
- 入力・文脈の取得（対象を特定）
  - `window.activeTextEditor`, `window.visibleTextEditors`, `workspace.textDocuments`
  - 変更検知: `workspace.onDidChangeTextDocument`, `workspace.onDidSaveTextDocument`, `workspace.onWillSaveTextDocument`
  - 選択/範囲: `TextEditor.selection`, `TextEditor.selections`
  - 差分/SCM: `scm.createSourceControl`, `window.showTextDocument`, `commands.executeCommand('vscode.diff', ...)`
- 実行のトリガー（いつ動くか）
  - コマンド/メニュー: `commands.registerCommand`, `commands.registerTextEditorCommand`
  - Activation Events（onLanguage/onCommand/onLanguageModelTool など、2.2.4 を参照）
  - イベント: `window.onDidChangeActiveTextEditor`, `workspace.onDidChangeWorkspaceFolders` ほか
- 解析・下準備（ローカル前処理）
  - 構文/言語情報: `languages.match`, `workspace.getConfiguration`
  - ファイル探索/読み込み: `workspace.findFiles`, `workspace.fs.readFile`
- 出力・提示（IDE内でのフィードバック）
  - 通知/UI: `window.showInformationMessage/WarningMessage/ErrorMessage`, `window.setStatusBarMessage`, `window.withProgress`
  - 診断（赤線/警告）: `languages.createDiagnosticCollection`
  - 修正アクション: `languages.registerCodeActionsProvider`
  - コメントスレッド: `comments.createCommentController`
  - サイドパネル/一覧: `window.createTreeView`, `window.registerTreeDataProvider`
  - リッチUI/プレビュー: `window.createWebviewPanel`, `registerWebviewViewProvider`
- 修正の適用（ドキュメント更新）
  - 編集: `workspace.applyEdit`, `TextEditor.edit`, `WorkspaceEdit.{insert,replace,delete,renameFile}`
  - コマンド駆動の編集: `commands.executeCommand('editor.action.rename', ...)` 等のビルトイン活用
- 外部連携・実行
  - タスク/ターミナル: `tasks.executeTask`, `window.createTerminal`
  - 外部URL/アプリ: `env.openExternal`, `window.registerUriHandler`
  - 認証: `authentication.getSession`
- セキュリティ/ガバナンス
  - Workspace Trust（2.3 ガイド参照）, 認証（`authentication.*`）

このマップは「レビュー対象の取得 → 解析 → 引用付き提示 → 修正適用 → 監査可能な外部連携」という流れに沿って、最小限のAPIセットを示します。詳細な全APIは以降の付録（2.2.3 以降）を参照してください。

### 2.2.2 レビュー処理の典型フロー（API対応）
1) 取得: `window.activeTextEditor` / `workspace.textDocuments` で対象を取得、必要に応じて `workspace.findFiles` で関連資料を探索。
2) 文脈: `TextEditor.selection(s)` と `scm`/diff（`vscode.diff`）で差分や範囲を確定。
3) 解析: 設定/言語情報（`workspace.getConfiguration`, `languages.match`）を読み込み、前処理。
4) 提示: 診断（`languages.createDiagnosticCollection`）、コメント（`comments.createCommentController`）、サイドバー（`createTreeView`）、通知（`window.show*Message`）。
5) 修正: `workspace.applyEdit` / `TextEditor.edit` で修正案を適用、`registerCodeActionsProvider` で Quick Fix を提供。
6) 連携: 参照リンクは `env.openExternal`、必要なスクリプト/検証は `tasks.executeTask` や `createTerminal` を使用。

---

### 2.2.3 設計〜運用ガイド（統合の要点）
- AI拡張（LM/Tools/Chat/MCP）
  - LM Tools でツール提供（Agent モードから自動/明示起動）、Chat/LM プロバイダで会話/モデル統合。
  - Prompt TSX で宣言的にプロンプト/入出力UIを表現。
- UI/機能拡張パターン
  - Command/Keybindings/Menus、Tree View、Webview、Custom Editors、Notebook、SCM、Task、Debugger、Testing、Telemetry。
- 拡張可能領域（Extension Capabilities）
  - Common Capabilities、Theming（Color/File Icon/Product Icon）、Workbench拡張（Activity/Sidebar/Status/Panel）。
- 言語拡張（Language Extensions）
  - Programmatic Language Features、LSP クライアント/サーバー、Syntax/Semantic Highlight、Language Configuration、Snippets、Embedded Languages。
- 高度な話題（Advanced Topics）
  - Extension Host、Proposed API、Remote/Codespaces、Workspace Trust、Web Extensions の制約。
- 参照（References）
  - Contribution Points / Activation Events / When‑clause / Document Selector / Built‑in Commands / Theme Color など。
- テスト/配布/CI（Working with Extensions）
  - Testing（Extension Hostでのテスト/デバッグ）→ Bundling（webpack/esbuild）→ Publishing（Marketplace/Publisher/Token/非推奨化ガイダンス）→ CI（GitHub Actions 等）。

### 2.2.4 能力カタログ（網羅・要点のみ）
- 対象・文脈の取得: アクティブエディタ、選択範囲、差分、ワークスペース、設定
- ライフサイクル/起動: コマンド、イベント、Activation Events
- 表示/インタラクション: 通知、StatusBar、QuickPick/InputBox、コメント、診断、TreeView、Webview
- 自動修正/編集: WorkspaceEdit、Code Actions（Quick Fix）
- 言語機能: 補完、ホバー、定義/参照、リネーム、フォーマット、シンボル、ハイライト
- デバッグ/実行: セッション、ブレークポイント、構成、コンソール
- ソース管理/レビュー: SCM、QuickDiff、diff表示、コミット支援
- タスク/ターミナル/外部連携: カスタムタスク、統合ターミナル、外部URI/アプリ
- ノートブック: タイプ/コントローラ/レンダラ/シリアライズ
- Webview/カスタムエディタ: リッチUI、可視化、専用編集体験
- 認証/セキュリティ/信頼: セッション、Workspace Trust、SecretStorage（必要に応じ）
- 設定/永続化: 設定管理、Memento
- テレメトリ/診断ログ: 必要最小限の利用方針で
- テスト/配布/CI: 拡張テスト、バンドル、Marketplace発行、CI連携


### 2.2.8 When-clause Contexts（条件式・代表キー）
- 演算子: 論理（! && ||）, 等価（== !=），比較（< <= > >=），正規表現マッチ（=~），in / not in
- 代表的なコンテキストキー（抜粋）
  - Editor: editorFocus, editorTextFocus, inputFocus, editorReadonly, editorHasSelection, editorLangId, isInDiffEditor
  - OS/環境: isLinux, isMac, isWindows, isWeb
  - Git/SCM: scmProvider, gitOpenRepositoryCount
  - Debug: inDebugMode, debuggersAvailable
  - リソース: resourceScheme, resourceExtname, resourceFilename
  - ビュー/ワークベンチ: view, viewItem, sidebarVisible, panelLocation

### 2.2.9 Document Selector（言語/スキーム/パターン指定）
- 形式: `string | { language?, scheme?, pattern?, notebookType? } | Array<...>`
- 例: `[{ language: 'markdown', scheme: 'file' }, { pattern: '**/*.md' }]`

### 2.2.10 Webview / Custom Editor / Webview View（ガイド抜粋）
- `window.createWebviewPanel` でエディタとして表示、`registerWebviewPanelSerializer` で復元。
- Custom Editors（独自エディタUI）/ Webview View（サイドバー）でも webview を利用可能。
- メッセージパッシングで拡張と双方向通信、`webview.asWebviewUri` で安全なリソース参照。


# 3. Databricks
## 3.1 強み
- 統合データ/AI基盤: SQL Warehouse、Unity Catalog、Vector Search、Serving、Jobs などを横断活用。
- ガバナンス: カタログ/権限/リネージ/タグによりデータ分類と監査が可能。
- API網羅性: Workspace SDK と REST API でほぼ全リソースを型安全に操作可能。
- スケール/コスト: マネージドな実行基盤とキャパシティ制御でスケール可能。

## 3.2 Databricks Workspace SDK/REST API ファミリ（ローカル参照に基づく）
- agentbricks: AgentBricksAPI
- aibuilder: AiBuilderAPI, CustomLlmsAPI
- apps: AppsAPI, AppsSettingsAPI
- catalog: ArtifactAllowlistsAPI, CatalogsAPI, ConnectionsAPI, CredentialsAPI, DatabaseInstancesAPI, EndpointsAPI, EntityTagAssignmentsAPI, ExternalLineageAPI, ExternalLocationsAPI, ExternalMetadataAPI, FunctionsAPI, GrantsAPI, LakehouseMonitorsAPI, MetastoresAPI, ModelVersionsAPI, OnlineTablesAPI, PoliciesAPI, QualityMonitorsAPI, RegisteredModelsAPI, ResourceQuotasAPI, RfaAPI, SchemasAPI, StorageCredentialsAPI, SystemSchemasAPI, TableConstraintsAPI, TablesAPI, TemporaryPathCredentialsAPI, TemporaryTableCredentialsAPI, VolumesAPI, WorkspaceBindingsAPI
- cleanrooms: CleanRoomAssetRevisionsAPI, CleanRoomAssetsAPI, CleanRoomAutoApprovalRulesAPI, CleanRoomsAPI, CleanRoomTaskRunsAPI
- compute: ClusterPoliciesAPI, ClustersExt, CommandExecutionAPI, GlobalInitScriptsAPI, InstancePoolsAPI, InstanceProfilesAPI, LibrariesAPI, PolicyComplianceForClustersAPI, PolicyFamiliesAPI
- dashboards: GenieAPI, LakeviewAPI, LakeviewEmbeddedAPI, QueryExecutionAPI
- database: DatabaseAPI
- files: DbfsExt, FilesAPI
- iam: AccessControlAPI, AccountAccessControlProxyAPI, CurrentUserAPI, GroupsAPI, PermissionMigrationAPI, PermissionsAPI, ServicePrincipalsAPI, UsersAPI
- jobs: JobsExt, PolicyComplianceForJobsAPI
- marketplace: ConsumerFulfillmentsAPI, ConsumerInstallationsAPI, ConsumerListingsAPI, ConsumerPersonalizationRequestsAPI, ConsumerProvidersAPI, ProviderExchangeFiltersAPI, ProviderExchangesAPI, ProviderFilesAPI, ProviderListingsAPI, ProviderPersonalizationRequestsAPI, ProviderProviderAnalyticsDashboardsAPI, ProviderProvidersAPI
- ml: ExperimentsAPI, FeatureStoreAPI, ForecastingAPI, MaterializedFeaturesAPI, ModelRegistryAPI
- oauth2: ServicePrincipalSecretsProxyAPI
- pipelines: PipelinesAPI
- provisioning: CredentialsAPI
- qualitymonitorv2: QualityMonitorV2API
- serving: AppsAPI, ServingEndpointsDataPlaneAPI, ServingEndpointsExt
- settings: AibiDashboardEmbeddingAccessPolicyAPI, AibiDashboardEmbeddingApprovedDomainsAPI, AutomaticClusterUpdateAPI, ComplianceSecurityProfileAPI, CredentialsManagerAPI, CspEnablementAPI, DashboardEmailSubscriptionsAPI, DefaultNamespaceAPI, DefaultWarehouseIdAPI, DisableLegacyAccessAPI, DisableLegacyDbfsAPI, EnableExportNotebookAPI, EnableNotebookTableClipboardAPI, EnableResultsDownloadingAPI, EnhancedSecurityMonitoringAPI, EsmEnablementAPI, IpAccessListsAPI, LlmProxyPartnerPoweredWorkspaceAPI, NotificationDestinationsAPI, RestrictWorkspaceAdminsAPI, SettingsAPI, SqlResultsDownloadAPI, TokenManagementAPI, TokensAPI, WorkspaceConfAPI
- settingsv2: WorkspaceSettingsV2API
- sharing: CleanRoomsAPI, ProvidersAPI, RecipientActivationAPI, RecipientFederationPoliciesAPI, RecipientsAPI, SharesAPI
- sql: AlertsAPI, AlertsLegacyAPI, AlertsV2API, DashboardsAPI, DashboardWidgetsAPI, DataSourcesAPI, DbsqlPermissionsAPI, QueriesAPI, QueriesLegacyAPI, QueryHistoryAPI, QueryVisualizationsAPI, QueryVisualizationsLegacyAPI, RedashConfigAPI, StatementExecutionAPI, WarehousesAPI
- tags: TagPoliciesAPI
- vectorsearch: VectorSearchEndpointsAPI, VectorSearchIndexesAPI
- workspace: GitCredentialsAPI, ReposAPI, SecretsAPI, WorkspaceExt


# 4. VS Code × Databricks が活きるケース（Agent Mode + Language Model Tool API 前提）

本節は、VS Code と Databricks を GitHub Copilot Agent モードと Language Model Tool API で連携させることで解ける「ユーザーの問題」を起点に、課題・解決策・効果をケース別に整理する。

## 4.1 ドキュメントレビュー（引用付き）
- 問題: レビューの指摘に根拠がなく、合意形成に時間がかかる。
- 課題:
  - 規程・ベストプラクティス・良質例を検索対象として整理・索引化する。
  - レビュー観点チェックリスト（テンプレ準拠/用語統一/必須章）を定義する。
  - Agent→LMツール→引用付き所見の出力フォーマットを決める。
- 解決策: Agent が編集中のMarkdownを入力に LM ツールを自動起動し、Databricks の知識（社内文書検索等）を引用付きで提示。
- 効果（KPI例）: 手戻り削減、一次レビュー時間短縮、引用付き指摘率↑。

## 4.2 変更差分の要点サマリ
- 問題: PRが大きく、重要変更点と観点の抽出に時間がかかる。
- 課題:
  - Git差分から要点を抽出する観点タグ（breaking/セキュリティ/性能等）を定義する。
  - 差分→関連規程/資産検索→要約のプロンプトと出力テンプレートを整備する。
  - 重要度/影響度のスコアリング基準を設ける。
- 解決策: Agent が Git 差分文脈を使い LM ツールで関連ナレッジを収集し、要点＋根拠リンクを要約提示。
- 効果（KPI例）: レビュー準備時間↓、重要指摘の網羅率↑、再質問回数↓。

## 4.3 コード/SQL 規約レビュー
- 問題: 命名/例外/ログ/SQL規約逸脱の指摘がレビューワー依存で抜け漏れ。
- 課題:
  - 規約項目（命名/例外/ログ/SQL句順/禁止関数）をリスト化し優先度を付ける。
  - 自動点検用のチェック観点をプロンプト/ルールとして定義する。
  - 参照リンクのソース（Wiki/標準/クエリ例）の範囲と優先順位を決める。
  - 厳格度レベル（標準/緩め）と適用条件を取り決める。
- 解決策: Agent がファイル/言語文脈から LM ツールを呼び出し、規約/実例を引用しつつ改善提案を提示（IDE内で読める形）。
- 効果（KPI例）: 規約違反件数↓、レビュー反復回数↓、標準化率↑。

## 4.4 データ参照のコンプライアンスチェック
- 問題: PII/機密データの扱いを見落としやすい。
- 課題:
  - テーブル/列→分類・リネージを照会するクエリ/視点を定義する。
  - 機密度に応じた推奨対策（マスキング/アクセス制御）の提示テンプレートを作る。
  - コードからデータ参照を抽出する対象言語/パターンを決める。
  - 結果に出典（カタログURL/定義）を必ず付す運用ルールを定める。
- 解決策: Agent がコードから参照推定し LM ツールで Databricks メタデータを照会、注意点（マスキング等）を提示。
- 効果（KPI例）: 逸脱検知率↑、是正までの時間↓、監査対応コスト↓。

## 4.5 変更影響分析（Impact Analysis）
- 問題: 下流のノートブック/BI/ジョブへの影響把握に時間。
- 課題:
  - 影響判定の対象（ノートブック/ジョブ/BI/外部連携）の範囲を定義する。
  - リネージ照会と要約の出力フォーマット（影響度/出典リンク）を決める。
  - 関連ドキュメント検索との結合表示ルールを作る。
- 解決策: Agent が変更対象を特定し LM ツールで関連メタ/ドキュメントを収集、影響候補と根拠リンクを一覧提示。
- 効果（KPI例）: 影響漏れ件数↓、レビュー着地までの期間↓。

## 4.6 保存済みクエリ/ダッシュボードの再利用
- 問題: 既存の良質資産が見つからず、二重実装が発生。
- 課題:
  - 再利用評価の観点（対象領域/更新日/所有者/人気度）を定義する。
  - 資産候補の提示フォーマット（TOP K/出典/注意点）を決める。
  - バージョン/権限/依存性の確認チェックリストを用意する。
- 解決策: Agent が目的文脈から LM ツールで既存資産を検索し、引用リンクと共に提示。
- 効果（KPI例）: 再利用率↑、新規作成工数↓、標準化推進。

## 4.7 Runbook 支援とインシデント初動
- 問題: 障害時の初動が属人化し時間がかかる。
- 課題:
  - 主要インシデント種別ごとの初動テンプレートとチェックリストを整備する。
  - 直近指標の要約観点（期間/主要メトリクス）と表示形式を決める。
  - 初動提案に必ず出典リンクを含める運用ルールを定める。
- 解決策: Agent が作業文脈から LM ツールで手順・事例・指標を束ね、根拠付き初動案を提示。
- 効果（KPI例）: MTTR↓、初動のばらつき↓、再発防止策の反映速度↑。

## 4.8 レポート/README/設計書ドラフト生成
- 問題: データに基づく文書の初稿作成に時間がかかる。
- 課題:
  - 文書テンプレ/章立てを定義し、章ごとの必須項目を明確にする。
  - 参照すべき数値と出典（SQL/テーブル）をカタログ化する。
  - 出力フォーマット（引用・表・脚注）のテンプレートを準備する。
  - 生成→人手レビュー→確定の運用フローを定める。
- 解決策: Agent がテンプレ/章立てに合わせて LM ツールで必要情報を収集し、引用付きの叩き台を生成。
- 効果（KPI例）: 初稿作成時間↓、引用の整合性↑、レビュー着地までの反復↓。

# 4. サンプルプロジェクト案
## 4.1. ドキュメント/コード レビューエージェント

- ねらい
  - IDE内で編集中のドキュメント/コードを、組織知（規程・標準・ベストプラクティス・メタデータ）に基づいて“引用付き”でレビュー可能にする。

- 想定ユーザー/シナリオ
  - 開発者のセルフレビュー（PR前のMarkdown/コード/SQL）
  - レビューワーの根拠付きレビュー作成支援（変更差分の要点抽出）
  - テックライター/アーキテクトのテンプレ準拠・用語統一チェック

- 要件（機能・概要）
  - FR-01: アクティブドキュメント/選択範囲/変更差分をレビュー対象として受け付ける
  - FR-02: 指摘ごとに少なくとも1つの引用（規程/実例/メタデータ）を提示する
  - FR-03: ドキュメント観点（テンプレ準拠、必須章、用語統一、曖昧表現検知）
  - FR-04: コード観点（命名、例外、ログ、SQL規約、セキュリティ）
  - FR-05: データ参照がある場合、データ分類（PII等）・リネージに基づく注意点を提示
  - FR-06: レビュー厳格度（標準/緩め）切替、IDE内での箇条書き＋引用リンク提示

- 要件（非機能・概要）
  - NFR-01: 標準レビューで平均5秒以内の応答
  - NFR-02: IDE外への送信は最小化（選択範囲/差分/メタ情報）
  - NFR-03: 通信の暗号化と監査ログ（誰が/何を/いつ）
  - NFR-04: 組織ポリシーで拡張の利用可否を集中管理

- 全体設計（コンセプト）
  - VS Code（Copilot Agent Mode）: 会話IF＋IDEコンテキスト
  - レビュー拡張: 対象収集、問い合わせ生成、結果整形
  - Gateway（社内API）: 認証/監査/レート制御/ルーティング（read-only）
  - Databricks 知識基盤: Vector Search（規程/Wiki/良質例）、SQL Warehouse（メタ/品質指標）、Unity Catalog（分類/リネージ）

- スコープ/非スコープ
  - スコープ: Markdown/設計書、Python/SQL のレビュー、引用提示、ガバナンス運用
  - 非スコープ: 自動修正のコミット/プッシュ、データの書き込み操作、IDE外クライアント

- MVP段階と評価指標
  - MVP-1: ドキュメントレビュー（テンプレ準拠/用語統一/抜け漏れ）＋引用
  - MVP-2: コードレビュー（命名/例外/ログ/SQL規約）＋参考実装提示
  - MVP-3: データ使用チェック（分類/リネージに基づく注意点）
  - 指標: IDE外遷移回数の削減、一次レビュー時間、引用付き指摘の採用率
